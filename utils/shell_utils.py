import os
import socket
import subprocess
from datetime import datetime
from rich.console import Console
from rich.markdown import Markdown
from rich.text import Text
from rich.panel import Panel
import requests
import platform
import getpass

console = Console()


def format_markdown_for_terminal(markdown_text):
    """
    Used to print a pretty version of markdown generated by a model to the terminal.
    
    Args:
        markdown_text (str): The markdown text to print
    """
    
    md = Markdown(markdown_text)
    console.print(Panel(md, expand=True, border_style="bold blue"))


def run_command(command, superuser=False, display_output=True):
    """
    Runs a shell command, capturing the stdout and stderr and printing them to the terminal with styling.
    
    Args:
        command (str): The shell command to run
        superuser (bool): Whether to run the command as a superuser
        
    Returns:
        tuple: A tuple containing the stdout and stderr of the command
    """

    full_stdout = []
    full_stderr = []
    os_type = platform.system()
    current_user = getpass.getuser()
    
    if superuser and os_type != "Windows" and not command.startswith("sudo") and current_user != "root":
        command = f"sudo {command}"
    
    try:
        process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)

        stdout_iter = iter(process.stdout.readline, '')
        stderr_iter = iter(process.stderr.readline, '')
            
        for stdout_line in stdout_iter:
            if display_output:
                print_fancy(stdout_line.strip(), italic=True, color="light_gray")
            full_stdout.append(stdout_line)
        
        for stderr_line in stderr_iter:
            if display_output:
                print_fancy(stderr_line.strip(), italic=True, color="red")
            full_stderr.append(stderr_line)

        process.stdout.close()
        process.stderr.close()
        process.wait()
    except Exception as e:
        full_stderr.append(str(e))

    return ''.join(full_stdout), ''.join(full_stderr)


def print_fancy(text, bold=False, italic=False, underline=False, color=None, bg=None):
    """
    Helper function to print styled text to the terminal with simple arguments using rich.
    
    Args:
        text (str): The text to print
        bold (bool): Whether to bold the text
        italic (bool): Whether to italicize the text
        underline (bool): Whether to underline the text
        color (str): The color to use for the text
        bg (str): The background color to use for the text
    """
    
    text_obj = Text(text)
    
    if bold:
        text_obj.stylize("bold")
    if italic:
        text_obj.stylize("italic")
    if underline:
        text_obj.stylize("underline")
    if color:
        text_obj.stylize(color)
    if bg:
        text_obj.stylize(f"on {bg}")

    console.print(text_obj)


def get_system_context():
    """
    Retrieves basic system information to use as context for the model.
    
    Returns:
        str: A string containing the system context information
    """
    
    # Operating system
    os_name = platform.system()
    os_version = platform.version()
    os_details = platform.uname()

    # Local network IP
    local_ip = socket.gethostbyname(socket.gethostname())

    # External IP
    try:
        external_ip = requests.get('https://api.ipify.org').text
    except requests.RequestException:
        external_ip = 'Unavailable'

    # Username
    username = getpass.getuser()

    # Current working directory
    cwd = os.getcwd()

    # Current date and time
    current_datetime = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    context = (
        f"**Operating System:** {os_name} {os_version}\n"
        f"**OS Details:** {os_details}\n"
        f"**Local Network IP:** {local_ip}\n"
        f"**External IP:** {external_ip}\n"
        f"**Username:** {username}\n"
        f"**Current Working Directory:** {cwd}\n"
        f"**Current Date and Time:** {current_datetime}"
    )

    return context


def is_included_in_path(dirpath):
    """
    Checks if a directory is included in the PATH environment variable.

    Args:
        dirpath (str): The directory to check.

    Returns:
        bool: True if the directory is in the PATH, False otherwise.
    """
    path_separator = ";" if os.name == "nt" else ":"
    path_dirs = os.environ["PATH"].split(path_separator)
    return dirpath in path_dirs


def add_to_path(dirpath):
    """
    Adds a directory to the PATH environment variable if it's not already included.

    Args:
        dirpath (str): The directory to add.

    Returns:
        bool: True if the directory was added, False if it was already in the PATH.
    """
    if not is_included_in_path(dirpath):
        if platform.system() == "Windows":
            # Update PATH permanently for the user
            path_dirs = os.environ["PATH"].split(";")
            path_dirs.append(dirpath)
            new_path = ";".join(path_dirs)
            subprocess.run(['setx', 'PATH', new_path], shell=True)

            # Update PATH for the current session
            os.environ["PATH"] = new_path
        else:
            # Append to the shell configuration file
            shell_config = os.path.expanduser("~/.bashrc")  # Change to ~/.zshrc if using zsh
            with open(shell_config, "a") as f:
                f.write(f'\nexport PATH="$PATH:{dirpath}"\n')

            # Create a temporary script to source the shell configuration
            script_path = create_shell_script(shell_config)
            subprocess.run([script_path], shell=True)

            # Clean up the temporary script
            os.remove(script_path)

        return True
    return False


def create_shell_script(shell_config):
    """
    Creates a temporary shell script to source the updated shell configuration.

    Args:
        shell_config (str): The path to the shell configuration file.

    Returns:
        str: The path to the created shell script.
    """
    script_content = f"""
    #!/bin/bash
    source {shell_config}
    """
    script_path = "/tmp/update_path.sh"
    with open(script_path, "w") as script_file:
        script_file.write(script_content)
    os.chmod(script_path, 0o755)  # Make the script executable
    return script_path
